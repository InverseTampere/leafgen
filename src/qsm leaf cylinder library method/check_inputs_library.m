function tf = check_inputs_library(LibraryDistributions,Nodes, ...
                                   LeafProperties)
tf = false;

%% Assert the existence of all fields of LibraryDistributions struct
fieldCheckLib = [isfield(LibraryDistributions,'dTypeLODinc'), ...
                 isfield(LibraryDistributions,'dTypeLODaz'), ...
                 isfield(LibraryDistributions,'dTypeLSD')];
fieldNamesLib = ["dTypeLODinc", ...
                 "dTypeLODaz", ...
                 "dTypeLSD"];
for iField = 1:length(fieldCheckLib)
    assert(fieldCheckLib(iField),"Nodes."+fieldNamesLib(iField)+...
           " is missing.")
end
%% Assert the existence of all fields of Nodes struct
fieldCheckNod = [isfield(Nodes,'cylinderLength'), ...
                 isfield(Nodes,'cylinderRadius'), ...
                 isfield(Nodes,'cylinderInclinationAngle'), ...
                 isfield(Nodes,'cylinderAzimuthAngle'), ...
                 isfield(Nodes,'cylinderLeafArea'), ...
                 isfield(Nodes,'pLODinc1'), ...
                 isfield(Nodes,'pLODinc2'), ...
                 isfield(Nodes,'pLODaz1'), ...
                 isfield(Nodes,'pLODaz2'), ...
                 isfield(Nodes,'pLSD1'), ...
                 isfield(Nodes,'pLSD2')];
fieldNamesNod = ["cylinderLength", ...
                 "cylinderRadius", ...
                 "cylinderInclinationAngle", ...
                 "cylinderAzimuthAngle", ...
                 "cylinderLeafArea", ...
                 "pLODinc1", ...
                 "pLODinc2", ...
                 "pLODaz1", ...
                 "pLODaz2", ...
                 "pLSD1", ...
                 "pLSD2"];
for iField = 1:length(fieldCheckNod)
    assert(fieldCheckNod(iField),"Nodes."+fieldNamesNod(iField)+...
           " is missing.")
end

%% Check the validity of cylinder attributes
% Cylinder length
if any(Nodes.cylinderLength <= 0) || ...
        ~all(Nodes.cylinderLength == sort(Nodes.cylinderLength))
    error("Nodes.cylinderLength can contain only positive values in"...
          +" ascending order.")
end
% Cylinder radius
if any(Nodes.cylinderRadius <= 0) || ...
        ~all(Nodes.cylinderRadius == sort(Nodes.cylinderRadius))
    error("Nodes.cylinderRadius can contain only positive values in"...
          +" ascending order.")
end
% Cylinder inclination angle
if any([any(Nodes.cylinderInclinationAngle < 0), ...
        any(Nodes.cylinderInclinationAngle > pi), ...
        ~all(Nodes.cylinderInclinationAngle == ...
             sort(Nodes.cylinderInclinationAngle))])
    error("Nodes.cylinderInclinationAngle can contain only values"...
          +" on the interval [0,pi] in ascending order.")
end
% Cylinder azimuth angle
if any([any(Nodes.cylinderAzimuthAngle < 0), ...
        any(Nodes.cylinderAzimuthAngle > 2*pi), ...
        ~all(Nodes.cylinderAzimuthAngle == ...
             sort(Nodes.cylinderAzimuthAngle))])
    error("Nodes.cylinderAzimuthAngle can contain only values"...
          +" on the interval [0,2*pi] in ascending order.")
end
% Cylinder leaf area
if any(Nodes.cylinderLeafArea <= 0) || ...
        ~all(Nodes.cylinderLeafArea == sort(Nodes.cylinderLeafArea))
    error("Nodes.cylinderLeafArea can contain only positive values in"...
          +" ascending order.")
end

%% Check the validity of distribution parameters
% LOD inclination angle distribution parameters
dTypeInc = LibraryDistributions.dTypeLODinc;
if ~any(strcmp(dTypeInc,{'uniform','spherical','dewit','beta'}))
    error("LOD inclination angle distribution type not recognized.")
end
switch dTypeInc
    case 'uniform'
        % parameters have no effect for uniform distribution
    case 'spherical'
        % parameters have no effect for spherical distribution
    case 'dewit'
        % Parameter a
        if any([any(Nodes.pLODinc1 < -1), ...
                any(Nodes.pLODinc1 > 1), ...
                ~all(Nodes.pLODinc1 == sort(Nodes.pLODinc1))])
            error("In case of generalized de Wit's distribution,"...
                  +" Nodes.pLODinc1 can contain only values on the"...
                 +" interval [-1,1] in ascending order.")
        end
        % Parameter b
        if any([any(Nodes.pLODinc2 < 2), ...
                any(Nodes.pLODinc2 > 4), ...
                ~all(Nodes.pLODinc2 == sort(Nodes.pLODinc2))])
            error("In case of generalized de Wit's distribution,"...
                  +" Nodes.pLODinc2 can contain only values on the"...
                 +" interval [2,4] in ascending order.")
        end
    case 'beta'
        % Parameter alpha
        if any([any(Nodes.pLODinc1 <= 0), ...
                ~all(Nodes.pLODinc1 == sort(Nodes.pLODinc1))])
            error("In case of beta distribution, Nodes.pLODinc1 can"...
                  +" contain only positive values in ascending order.")
        end
        % Parameter beta
        if any([any(Nodes.pLODinc2 <= 0), ...
                ~all(Nodes.pLODinc2 == sort(Nodes.pLODinc2))])
            error("In case of beta distribution, Nodes.pLODinc2 can"...
                  +" contain only positive values in ascending order.")
        end
end
% LOD azimuth angle distribution parameters
dTypeAz = LibraryDistributions.dTypeLODaz;
if ~any(strcmp(dTypeAz,{'uniform','vonmises'}))
    error("LOD azimuth angle distribution type not recognized.")
end
switch dTypeAz
    case 'uniform'
        % parameters have no effect for uniform distribution
    case 'vonmises'
        % Mean parameter
        if any([any(Nodes.pLODaz1 < 0), ...
                any(Nodes.pLODaz1 > 2*pi), ...
                ~all(Nodes.pLODaz1 == sort(Nodes.pLODaz1))])
            error("In case of von Mises distribution, Nodes.pLODaz1"...
                  +" can contain only values on the interval [0,2*pi]"...
                  +" in ascending order.")
        end
        % Concentration parameter
        if any(Nodes.pLODaz2 < 0) || ...
                ~all(Nodes.pLODaz2 == sort(Nodes.pLODaz2))
            error("In case of von Mises distribution, Nodes.pLODaz2"...
                  +" can contain only positive values in ascending order.")
        end

end
% LSD distribution parameters
dTypeLSD = LibraryDistributions.dTypeLSD;
if ~any(strcmp(dTypeLSD,{'constant','uniform','normal'}))
    error("Leaf size distribution type not recognized.")
end
switch dTypeLSD
    case 'constant'
        if any(Nodes.pLSD1 <= 0) || ...
                ~all(Nodes.pLSD1 == sort(Nodes.pLSD1))
            error("In case of constant leaf size, Nodes.pLSD1 can"...
                  +" contain only positive values in ascending order.")
        end
    case 'uniform'
        % Lower bound
        if any(Nodes.pLSD1 <= 0) || ...
                ~all(Nodes.pLSD1 == sort(Nodes.pLSD1))
            error("In case of uniform distribution, Nodes.pLSD1 can"...
                  +" contain only positive values in ascending order.")
        end
        % Upper bound
        if any(Nodes.pLSD2 <= 0) || ...
                ~all(Nodes.pLSD2 == sort(Nodes.pLSD2))
            error("In case of uniform distribution, Nodes.pLSD2 can"...
                  +" contain only positive values in ascending order.")
        end
        % Ensuring that lower bound doesn't exeed upper bound
        if max(Nodes.pLSD1) >= min(Nodes.pLSD2)
            error("In case of uniform distribution, the values of"...
                  +" Nodes.pLSD1 have to be lower than the lowest value"...
                  +" of pLSD2.")
        end
    case 'normal'
        % Mean parameter
        if any(Nodes.pLSD1 <= 0) || ...
                ~all(Nodes.pLSD1 == sort(Nodes.pLSD1))
            error("In case of normal distribution, Nodes.pLSD1 can"...
                  +" contain only positive values in ascending order.")
        end
        % Variance parameter
        if any(Nodes.pLSD2 <= 0) || ...
                ~all(Nodes.pLSD2 == sort(Nodes.pLSD2))
            error("In case of normal distribution, Nodes.pLSD2 can"...
                  +" contain only positive values in ascending order.")
        end
        % Warning if there is significant probability mass below zero
        if min(Nodes.pLSD1) - 3*sqrt(max(Nodes.pLSD2)) < 0
            warning("LSD normal distribution has significant"...
                    +" probability mass below zero. (All"...
                    +" negative samples will be discarded).")
        end
end

%% Check the leaf base geometry and twig length limits
if size(LeafProperties.vertices,2) ~= 3
    error("LeafProperties.vertices should have a size (nVertices x 3).")
end
if size(LeafProperties.triangles,2) ~= 3
    error("LeafProperties.triangles should have a size (nTriangles x 3).")
end
if max(LeafProperties.triangles,[],'all') > size(LeafProperties.vertices,1)
    error("LeafProperties.triangles refers to too large vertice indices.")
end
if any(LeafProperties.twigLengthLimits < 0) || ...
        ~all(LeafProperties.twigLengthLimits ...
             == sort(LeafProperties.twigLengthLimits))
    error("LeafProperties.twigLengthLimits can contain only positive"...
          +" values in ascending order.")
end
if length(LeafProperties.twigLengthLimits) ~= 2
    error("LeafProperties.twigLengthLimits can contain only two elements.")
end

tf = true;

end